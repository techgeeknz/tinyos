#!/bin/busybox sh
# TinyOS early userspace (initramfs). BusyBox static, devtmpfs + mdev.
# Goal: fast boot to a recovery shell for EFI tweaks (e.g., rEFInd config), no in-init editor.
# Handoff to BusyBox init by default.


# Bind stdin/stdout/stderr to the console early
exec </dev/console >/dev/console 2>&1
set -eu
export PATH=/sbin:/bin:/usr/sbin:/usr/bin
export LANG=C LC_ALL=C

BB=/bin/busybox
link_bb() {
  if [ -h "$BB" ]; then
    "$BB" ln -snfb "$("$BB" readlink "$BB")" "$1" || true
  else
    "$BB" ln -snfb "$BB" "$1" || true
  fi
}

# Millisecond-ish uptime stamp like the kernel
_ts()   { "$BB" awk '{printf "[%10.6f]", $1}' /proc/uptime 2>/dev/null ||
          printf "[   .      ]"; }
msg()   { printf "%s %s %s\n" "$(_ts)" "[init]" "$*" >&2; }
log()   { { [ "${VERBOSE:0}" -eq 0 ] && [ "${QUIET:-0}" -gt 0 ]; } ||
          msg "$*"; }
panic() { msg 'ERROR:' "$*"; exec "$BB" setsid "$BB" cttyhack "$BB" sh; }
trap 'rc=$?; [ $rc -eq 0 ] || panic "init exited with status $rc";' EXIT

# Pseudo-fs (idempotent)
mnt_pfs() { "$BB" mount -t "$1" "$2" "$3" || panic "mnt_pfs: mount $3 failed"; }
"$BB" mkdir -p /proc /sys /dev
mnt_pfs proc     proc     /proc
mnt_pfs sysfs    sysfs    /sys
mnt_pfs devtmpfs devtmpfs /dev
"$BB" rm -rf /run 2>/dev/null || true; "$BB" mkdir -p /run || true
if "$BB" ln -snf /proc/$$/exe /run/busybox; then
  BB=/run/busybox
fi

# --- Kernel cmdline (for feature toggles) ---
CFG=/etc/tinyos.conf
_CMD_TOOLS_HINT=
_CMD_ESP_HINT=
CMDLINE="$("$BB" cat /proc/cmdline 2>/dev/null || true)"

for tok in $CMDLINE; do
  case "$tok" in
    quiet|tinyos.quiet)
      export QUIET=1 ;;
    tinyos.debug|tinyos.trace)
      export VERBOSE=1 QUIET=0
      # Pretty xtrace with kernel-like timestamp + line number
      export PS4='+$(_ts) ${LINENO}: '
      set -eux  # enable xtrace too
      # Optional: crank printk so kernel messages are visible
      echo "7 4 1 7" >/proc/sys/kernel/printk 2>/dev/null || true
      log "debug tracing enabled via kernel cmdline"
      ;;
    tinyos.noconf)
      # Disable tinyos.conf parsing
      CFG="" ;;
    tinyos.tools=*)
      # Override hint for TOOLS partition
      _CMD_TOOLS_HINT="${tok#tinyos.tools=}" ;;
    tinyos.esp=*)
      # Override hint for ESP partition
      _CMD_ESP_HINT="${tok#tinyos.esp=}" ;;
    *) ;;
  esac
done

if [ "$QUIET" -eq 0 ] && [ "$VERBOSE" -eq 0 ]; then
  # Quiet the kernel a touch (best-effort)
  echo 3 4 1 3 > /proc/sys/kernel/printk 2>/dev/null || true
fi

# finish setting up essential FSH directories
"$BB" rm -rf /tmp /mnt || true
"$BB" mkdir -p /tmp /mnt /run/lock /run/log || true
"$BB" chmod 1777 /tmp || true
"$BB" chmod 0755 /run /run/lock /run/log || true

# Finish setting up /dev
[ -d /dev/pts ] || { "$BB" rm -rf /dev/pts; "$BB" mkdir -p /dev/pts; }
"$BB" mountpoint -q /dev/pts || "$BB" mount -t devpts devpts /dev/pts || true
[ -e /dev/ptmx ] || "$BB" ln -s /dev/pts/ptmx /dev/ptmx || true

# BusyBox self-install (foreground, critical)
# (We do this early so all applets are available.)
log "install busybox"
"$BB" [ ! -e /tbin ] || "$BB" rm -rf /tbin
"$BB" mkdir -p /tbin
"$BB" --install -s /tbin
"$BB" mv -nt /bin /tbin/* /tbin/.[!.]* /tbin/..?* || true
"$BB" rm -rf /tbin

# Enforce a unified /bin ( /sbin -> /bin preferred, but /bin -> /sbin okay)
[ -d /sbin ] || { [ ! -e /sbin ] || "$BB" rm -f /sbin; "$BB" ln -snf /bin /sbin; }
if [ "$("$BB" realpath /bin)" != "$("$BB" realpath /sbin)" ]; then
  log "unifying /sbin -> /bin"
  "$BB" mkdir -p /tbin
  "$BB" mv -ft /tbin /sbin/* /sbin/.[!.]* /sbin/..?* || true
  "$BB" mv -ft /tbin /bin/*  /bin/.[!.]*  /bin/..?*  || true
  "$BB" rm -rf /bin /sbin
  "$BB" mv -f  /tbin /bin
  "$BB" ln -snf /bin /sbin
fi

# Bring up mdev for /dev population and hotplug handling
if [ -e /sbin/mdev ]; then
  log "Starting mdev daemon"
  link_bb /sbin/mdev
  echo /sbin/mdev > /proc/sys/kernel/hotplug || true
  /sbin/mdev -s
fi

# Defaults (can be overridden via /etc/tinyos.conf)
export TOOLS_MOUNT=/boot/tools
export ESP_MOUNT=/boot/efi
export TINYOS_REL="EFI/tinyos"

# Additional config knobs (optional):
#   TOOLS_HINT, ESP_HINT   : one of LABEL=…, UUID=…, PARTUUID=…, PARTLABEL=…, or /dev/…
export TOOLS_HINT=""
export ESP_HINT=""

# Optional config file: KEY=VALUE only (VALUE is stripped of leading/trailing
# whitespace, but is otherwise literal; blank lines and full-line comments
# are ignored; whitespace around = is ignored).
# Sanitize to a temp file that contains only `unset KEY` and `KEY='VALUE'`,
# then source it.
if [ -z "$CFG" ]; then
  log "skipping config overrides (disabled by commandline)"
elif ! [ -f "$CFG" ]; then
  log "skipping config overrides ($CFG file not found)"
else
  log "applying config overrides from $CFG"

  _TMP_CONF="/run/tinyos.conf"
  "$BB" awk -f - "$CFG" >"$_TMP_CONF" <<'AWK'
    {
      # Match key (stripped of whitespace) and entire RHS
      if match($0, /^[[:space:]]*([A-Z][A-Z0-9_]*)[[:space:]]*=(.*)$/, m) {
        key = m[1]; val = m[2];
        # Strip whitespace from RHS
        gsub(/^[[:space:]]+|[[:space:]]+$/, "", val);
        if (val == "") { printf "unset %s\n", key; next }

        # Quote value for shell
        gsub(/'/, "'\\''", val)
        printf "export %s='%s'\n", key, val
      }
    }
    END {
      printf "\n"
    }
AWK

  # Source the sanitized config file
  . "$_TMP_CONF"
  unset _TMP_CONF
fi

# Normalize config-derived paths:
# - TOOLS_MOUNT: strip trailing /
# - TINYOS_REL : strip leading and trailing / (keep 'EFI/...', do not make it absolute)
# - ESP_MOUNT  : strip trailing /
TOOLS_MOUNT="$("$BB" realpath "${TOOLS_MOUNT%/}")"
TINYOS_REL="${TINYOS_REL#/}"
TINYOS_REL="${TINYOS_REL%/}"
ESP_MOUNT="$("$BB" realpath "${ESP_MOUNT%/}")"

# Resolved paths used everywhere else
# NOTE: keep EFI/ — do NOT strip it.
export TINYOS_DIR="${TOOLS_MOUNT}/${TINYOS_REL}"

# Create filesystem mountpoints
"$BB" mkdir -p "$ESP_MOUNT" "$TOOLS_MOUNT"

# -------- sysfs helpers --------
set_sysfs() { # set_sysfs <abs-or-rel-path-under-/sys> <value>
  p="$1"; v="$2"
  # 1) Normalize to an absolute path under /sys
  case "$p" in
    /sys/*) abs="$p" ;;
    /*)     log "sysfs: reject absolute path outside /sys: '$p'"; return 1 ;;
    *)      abs="/sys/${p#/}" ;;
  esac
  # 2) Cheap traversal guard even without canonicalization
  case "$abs" in *"/.."*|*"../"*) log "sysfs: reject path with '..': '${abs#/sys/}'"; return 1 ;; esac
  # 3) Canonicalize with BusyBox readlink (if it resolves, enforce /sys prefix)
  rp="$("$BB" readlink -f -- "$abs" 2>/dev/null || true)"
  if [ -n "$rp" ]; then
    case "$rp" in /sys/*) abs="$rp" ;; *) log "sysfs: canonical path escapes /sys: '$rp'"; return 1 ;; esac
  fi
  # 4) Write if writable
  if [ -w "$abs" ]; then
    printf '%s' "$v" >"$abs" 2>/dev/null && { log "sysfs: set ${abs#/sys/}='$v'"; return 0; }
  fi
  log "sysfs: cannot set ${abs#/sys/} (not writable?)"; return 1
}
apply_sysfs_dir() { # apply_sysfs_dir <dir> ; *.conf "path = value", comments/# ok
  d="$1"; [ -d "$d" ] || return 0
  log "applying sysfs tweaks from $d"
  for f in "$d"/*.conf; do
    [ -e "$f" ] || continue
    while IFS= read -r line || [ -n "$line" ]; do
      case "$line" in \#*|'') continue;;
        *=*) k="${line%%=*}"; v="${line#*=}";;
        *) continue;;
      esac
      k="$(printf '%s' "$k" | "$BB" sed -r 's/^[[:space:]]+//; s/[[:space:]]+$//')"
      v="$(printf '%s' "$v" | "$BB" sed -r 's/^[[:space:]]+//; s/[[:space:]]+$//')"
      # Warn if an absolute path is not under /sys (it will be rejected by set_sysfs anyway)
      case "$k" in /sys/*) : ;; /*) log "sysfs: warning: absolute path not under /sys: '$k'";; esac
      [ -n "$k" ] && set_sysfs "$k" "$v" || true
    done <"$f"
  done
}

# --- Apply initramfs sysfs.d early (before any external mounts) ---
apply_sysfs_dir "/etc/sysfs.d"

# Resolve a device from a "hint" (LABEL=…, UUID=…, PARTUUID=…, PARTLABEL=…, or /dev/…)
resolve_hint() { # $1: hint
  h="$1"
  case "$h" in
    LABEL=*|UUID=*|PARTUUID=*|PARTLABEL=*) "$BB" blkid -t "$h" -o device 2>/dev/null | "$BB" head -n1 ;;
    /dev/*) printf '%s\n' "$h" ;;
    *)      printf '\n' ;;
  esac
}
mount_fat_ro() {  # $1:dev $2:mountpoint
  dev="$1"; mnt="$2"
  "$BB" mount -t vfat -o ro,nodev,nosuid,noexec "$dev" "$mnt" 2>/dev/null ||
  "$BB" mount -t vfat -o ro "$dev" "$mnt" 2>/dev/null || return 1
}

# ---------- HP_TOOLS (toolbox partition) ----------
log "discovering HP_TOOLS partition"
export TOOLS_DEV=""
# Seed from config or cmdline hint if provided
if [ -n "${_CMD_TOOLS_HINT:-}" ]; then
  TOOLS_HINT="$_CMD_TOOLS_HINT"
fi
if [ -z "${TOOLS_DEV:-}" ] && [ -n "$TOOLS_HINT" ]; then
  TOOLS_DEV="$(resolve_hint "$TOOLS_HINT" || true)"
fi

# Try explicit device first (if given)
if [ -n "${TOOLS_DEV:-}" ]; then
  mount_fat_ro "$TOOLS_DEV" "$TOOLS_MOUNT" || { "$BB" umount "$TOOLS_MOUNT" 2>/dev/null || true; TOOLS_DEV=""; }
fi

# Otherwise, prefer a VFAT device whose LABEL is exactly HP_TOOLS (enforced by firmware)
if [ -z "${TOOLS_DEV:-}" ]; then
  TOOLS_DEV="$(resolve_hint "LABEL=HP_TOOLS" || true)"
  if [ -n "${TOOLS_DEV:-}" ]; then
    mount_fat_ro "$TOOLS_DEV" "$TOOLS_MOUNT" || { "$BB" umount "$TOOLS_MOUNT" 2>/dev/null || true; TOOLS_DEV=""; }
  fi
fi

# As a final fallback, probe all VFAT devices and match LABEL value
if [ -z "${TOOLS_DEV:-}" ]; then
  for d in $("$BB" blkid -t TYPE=vfat -o device 2>/dev/null || true); do
    lbl="$("$BB" blkid -s LABEL -o value "$d" 2>/dev/null || true)"
    [ "${lbl:-}" = "HP_TOOLS" ] || continue
    mount_fat_ro "$d" "$TOOLS_MOUNT" || { "$BB" umount "$TOOLS_MOUNT" 2>/dev/null || true; continue; }
    TOOLS_DEV="$d"; break
  done
fi

# Uniform logging regardless of discovery method
if [ -n "${TOOLS_DEV:-}" ]; then
  log "HP_TOOLS $TOOLS_DEV mounted on $TOOLS_MOUNT"
else
  msg "HP_TOOLS not found (continuing with embedded assets only)"
fi

# ---------- ESP (real EFI System Partition) ----------
log "discovering ESP"
export ESP_DEV=""
# Seed from config or cmdline hint if provided
if [ -n "${_CMD_ESP_HINT}" ]; then
  ESP_HINT="$_CMD_ESP_HINT"
fi
if [ -z "${ESP_DEV:-}" ] && [ -n "$ESP_HINT" ]; then
  ESP_DEV="$(resolve_hint "$ESP_HINT" || true)"
fi
# Never treat HP_TOOLS as ESP
if [ -n "${TOOLS_DEV:-}" ] && [ -n "${ESP_DEV:-}" ] && [ "$ESP_DEV" = "$TOOLS_DEV" ]; then
  ESP_DEV=""
fi

# Try explicit device first (if given)
if [ -n "${ESP_DEV:-}" ]; then
  if ! mount_fat_ro "$ESP_DEV" "$ESP_MOUNT" || [ ! -d "$ESP_MOUNT/EFI" ]; then
    "$BB" umount "$ESP_MOUNT" 2>/dev/null || true
    ESP_DEV=""
  fi
fi

# Otherwise, probe: first VFAT with /EFI, excluding HP_TOOLS
if [ -z "${ESP_DEV:-}" ]; then
  for d in $("$BB" blkid -t TYPE=vfat -o device 2>/dev/null || true); do
    [ -n "${TOOLS_DEV:-}" ] && [ "$d" = "$TOOLS_DEV" ] && continue
    mount_fat_ro "$d" "$ESP_MOUNT" || continue
    if [ -d "$ESP_MOUNT/EFI" ]; then ESP_DEV="$d"; break; fi
    "$BB" umount "$ESP_MOUNT" 2>/dev/null || true
  done
fi

# Uniform logging regardless of discovery method
if [ -n "${ESP_DEV:-}" ]; then
  log "ESP $ESP_DEV mounted on $ESP_MOUNT"
else
  msg "ESP not found (continuing)"
fi

# Brute-force load all initramfs modules (temporary workaround for console)
KVER="$("$BB" uname -r)"
"$BB" find "/lib/modules/$KVER/" -name '*.ko*' -print0 | "$BB" xargs -r0 modprobe || true

# ---------- Bind in external modules/firmware from HP_TOOLS ----------

# Modules: bind only if directory appears to contain supplemental assets, ignore otherwise
MOD_EXT="$TINYOS_DIR/lib/modules/$KVER"
if [ -d "$MOD_EXT" ] && \
   "$BB" find "$MOD_EXT" \
     -type f \( -name '*.ko' -o -name '*.ko.*' -o -name 'modules.dep*' -o -name 'modules.*' \) \
     -print 2>/dev/null | "$BB" head -n1 >/dev/null; then
  log "mounting kernel modules payload"
  "$BB" mkdir -p "/lib/modules/$KVER"
  "$BB" mountpoint -q "/lib/modules/$KVER" || "$BB" mount --bind "$MOD_EXT" "/lib/modules/$KVER" 2>/dev/null || true
fi

# Firmware: bind (and set runtime search path) only if non-empty and no cmdline override
FW_EXT="$TINYOS_DIR/lib/firmware"
if [ -d "$FW_EXT" ] && \
   "$BB" find "$FW_EXT" -type f -print 2>/dev/null | "$BB" head -n1 >/dev/null; then
  if ! printf '%s' "$CMDLINE" | "$BB" tr ' ' '\n' | "$BB" grep -q '^firmware_class.path='; then
    log "mounting kernel firmware payload"
    "$BB" mkdir -p /lib/firmware
    "$BB" mountpoint -q /lib/firmware || "$BB" mount --bind "$FW_EXT" /lib/firmware 2>/dev/null || true
    set_sysfs "/sys/module/firmware_class/parameters/path" "/lib/firmware" || true
  else
   msg "not mounting kernel firmware payload, search path overridden by kernel cmdline"
  fi
fi

# Apply HP_TOOLS sysfs.d after it’s available
apply_sysfs_dir "$TINYOS_DIR/sysfs.d"

# Optional niceties (ignore failures)
"$BB" modprobe hp_wmi     2>/dev/null || true
"$BB" modprobe lis3lv02d  2>/dev/null || true
"$BB" modprobe rfkill     2>/dev/null || true

msg 'Dropping to shell (type "exit" to resume boot)'
"$BB" setsid "$BB" cttyhack "$BB" sh

msg 'Handing off to BusyBox init (PID stays 1)'
link_bb /sbin/init
exec /sbin/init
panic "/sbin/init failed; dropping to shell"
