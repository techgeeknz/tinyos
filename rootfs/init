#!/bin/busybox sh
# TinyOS early userspace (initramfs). BusyBox static, devtmpfs + mdev.
# Goal: fast boot to a recovery shell for EFI tweaks (e.g., rEFInd config), no in-init editor.
# Handoff to BusyBox init by default.


# Bind stdin/stdout/stderr to the console early
exec </dev/console >/dev/console 2>&1
set -eu
export PATH=/sbin:/bin:/usr/sbin:/usr/bin
export LANG=C LC_ALL=C

MANIFEST_TEMPLATE="tinyos-{}.manifest"
subst_template() { # $1 template, $2 value
  echo "${1%\{\}*}$2${1#*\{\}}"
}

BB=/bin/busybox
link_bb() {
  if [ -h "$BB" ]; then
    "$BB" ln -snfb "$("$BB" readlink "$BB")" "$1" || true
  else
    "$BB" ln -snfb "$BB" "$1" || true
  fi
}

# Millisecond-ish uptime stamp like the kernel
_ts()   { "$BB" awk '{printf "[%10.6f]", $1}' /proc/uptime 2>/dev/null ||
          printf "[   .      ]"; }
msg()   { printf "%s %s %s\n" "$(_ts)" "[init]" "$*" >&2; }
log()   { { [ "${VERBOSE:0}" -eq 0 ] && [ "${QUIET:-0}" -gt 0 ]; } ||
          msg "$*"; }
panic() { msg 'ERROR:' "$*"; exec "$BB" setsid "$BB" cttyhack "$BB" sh; }
trap 'rc=$?; [ $rc -eq 0 ] || panic "init exited with status $rc";' EXIT

# Pseudo-fs (idempotent)
mnt_pfs() { "$BB" mount -t "$1" "$2" "$3" || panic "mnt_pfs: mount $3 failed"; }
"$BB" mkdir -p /proc /sys /dev
mnt_pfs proc     proc     /proc
mnt_pfs sysfs    sysfs    /sys
mnt_pfs devtmpfs devtmpfs /dev
"$BB" rm -rf /run 2>/dev/null || true; "$BB" mkdir -p /run || true
if "$BB" ln -snf /proc/$$/exe /run/busybox; then
  BB=/run/busybox
fi

# --- Kernel cmdline (for feature toggles) ---
CFG=/etc/tinyos.conf
_CMD_TOOLS_HINT=
_CMD_ESP_HINT=
CMDLINE="$("$BB" cat /proc/cmdline 2>/dev/null || true)"

for tok in $CMDLINE; do
  case "$tok" in
    quiet|tinyos.quiet)
      export QUIET=1 ;;
    tinyos.debug|tinyos.trace)
      export VERBOSE=1 QUIET=0
      # Pretty xtrace with kernel-like timestamp + line number
      export PS4='+$(_ts) ${LINENO}: '
      set -eux  # enable xtrace too
      # Optional: crank printk so kernel messages are visible
      echo "7 4 1 7" >/proc/sys/kernel/printk 2>/dev/null || true
      log "debug tracing enabled via kernel cmdline"
      ;;
    tinyos.noconf)
      # Disable tinyos.conf parsing
      CFG="" ;;
    tinyos.tools=*)
      # Override hint for TOOLS partition
      _CMD_TOOLS_HINT="${tok#tinyos.tools=}" ;;
    tinyos.esp=*)
      # Override hint for ESP partition
      _CMD_ESP_HINT="${tok#tinyos.esp=}" ;;
    *) ;;
  esac
done

if [ "$QUIET" -eq 0 ] && [ "$VERBOSE" -eq 0 ]; then
  # Quiet the kernel a touch (best-effort)
  echo 3 4 1 3 > /proc/sys/kernel/printk 2>/dev/null || true
fi

# finish setting up essential FSH directories
"$BB" rm -rf /tmp /mnt || true
"$BB" mkdir -p /tmp /mnt /run/lock /run/log || true
"$BB" chmod 1777 /tmp || true
"$BB" chmod 0755 /run /run/lock /run/log || true

# Finish setting up /dev
[ -d /dev/pts ] || { "$BB" rm -rf /dev/pts; "$BB" mkdir -p /dev/pts; }
"$BB" mountpoint -q /dev/pts || "$BB" mount -t devpts devpts /dev/pts || true
[ -e /dev/ptmx ] || "$BB" ln -s /dev/pts/ptmx /dev/ptmx || true

# BusyBox self-install (foreground, critical)
# (We do this early so all applets are available.)
log "install busybox"
"$BB" [ ! -e /tbin ] || "$BB" rm -rf /tbin
"$BB" mkdir -p /tbin
"$BB" --install -s /tbin
"$BB" mv -nt /bin /tbin/* /tbin/.[!.]* /tbin/..?* || true
"$BB" rm -rf /tbin

# Enforce a unified /bin ( /sbin -> /bin preferred, but /bin -> /sbin okay)
[ -d /sbin ] || { [ ! -e /sbin ] || "$BB" rm -f /sbin; "$BB" ln -snf /bin /sbin; }
if [ "$("$BB" realpath /bin)" != "$("$BB" realpath /sbin)" ]; then
  log "unifying /sbin -> /bin"
  "$BB" mkdir -p /tbin
  "$BB" mv -ft /tbin /sbin/* /sbin/.[!.]* /sbin/..?* || true
  "$BB" mv -ft /tbin /bin/*  /bin/.[!.]*  /bin/..?*  || true
  "$BB" rm -rf /bin /sbin
  "$BB" mv -f  /tbin /bin
  "$BB" ln -snf /bin /sbin
fi

# Bring up mdev for /dev population and hotplug handling
if [ -e /sbin/mdev ]; then
  log "Starting mdev daemon"
  link_bb /sbin/mdev
  echo /sbin/mdev > /proc/sys/kernel/hotplug || true
  /sbin/mdev -s
fi

# Core config (required for finding and mounting payload):
export TOOLS_MOUNT=/boot/tools
export ESP_MOUNT=/boot/efi
export TINYOS_REL="EFI/tinyos"
export TINYOS_TOKEN=

# Additional config knobs (optional):
#   TOOLS_HINT, ESP_HINT   : one of LABEL=…, UUID=…, TYPE=…, or /dev/…
export TOOLS_HINT=""
export ESP_HINT=""

# Config file: KEY=VALUE only (VALUE is stripped of leading/trailing
# whitespace, but is otherwise literal; blank lines and full-line comments
# are ignored; whitespace around = is ignored).
# Sanitize to a temp file that contains only `unset KEY` and `KEY='VALUE'`,
# then source it.
if [ -z "$CFG" ]; then
  log "skipping config overrides (disabled by commandline)"
elif [ ! -f "$CFG" ]; then
  log "skipping config overrides ($CFG file not found)"
else
  log "applying config overrides from $CFG"

  _TMP_CONF="/run/tinyos.conf"
  "$BB" awk -f - "$CFG" >"$_TMP_CONF" <<'AWK'
    {
      # Match key (stripped of whitespace) and entire RHS
      if match($0, /^[[:space:]]*([A-Z][A-Z0-9_]*)[[:space:]]*=(.*)$/, m) {
        key = m[1]; val = m[2];
        # Strip whitespace from RHS
        gsub(/^[[:space:]]+|[[:space:]]+$/, "", val);
        if (val == "") { printf "unset %s\n", key; next }

        # Quote value for shell
        gsub(/'/, "'\\''", val)
        printf "export %s='%s'\n", key, val
      }
    }
    END {
      printf "\n"
    }
AWK

  # Source the sanitized config file
  . "$_TMP_CONF"
  unset _TMP_CONF
fi

# Normalize config-derived paths:
# - TOOLS_MOUNT: strip trailing /
# - TINYOS_REL : strip leading and trailing / (keep 'EFI/...', do not make it absolute)
# - ESP_MOUNT  : strip trailing /
TOOLS_MOUNT="$("$BB" realpath "${TOOLS_MOUNT%/}")"
TINYOS_REL="${TINYOS_REL#/}"
TINYOS_REL="${TINYOS_REL%/}"
ESP_MOUNT="$("$BB" realpath "${ESP_MOUNT%/}")"

# -------- sysfs helpers --------
set_sysfs() { # set_sysfs <abs-or-rel-path-under-/sys> <value>
  p="$1"; v="$2"
  # 1) Normalize to an absolute path under /sys
  case "$p" in
    /sys/*) abs="$p" ;;
    /*)     log "sysfs: reject absolute path outside /sys: '$p'"; return 1 ;;
    *)      abs="/sys/${p#/}" ;;
  esac
  # 2) Cheap traversal guard even without canonicalization
  case "$abs" in *"/.."*|*"../"*) log "sysfs: reject path with '..': '${abs#/sys/}'"; return 1 ;; esac
  # 3) Canonicalize with BusyBox readlink (if it resolves, enforce /sys prefix)
  rp="$("$BB" readlink -f -- "$abs" 2>/dev/null || true)"
  if [ -n "$rp" ]; then
    case "$rp" in /sys/*) abs="$rp" ;; *) log "sysfs: canonical path escapes /sys: '$rp'"; return 1 ;; esac
  fi
  # 4) Write if writable
  if [ -w "$abs" ]; then
    printf '%s' "$v" >"$abs" 2>/dev/null && { log "sysfs: set ${abs#/sys/}='$v'"; return 0; }
  fi
  log "sysfs: cannot set ${abs#/sys/} (not writable?)"; return 1
}
apply_sysfs_dir() { # apply_sysfs_dir <dir> ; *.conf "path = value", comments/# ok
  d="$1"; [ -d "$d" ] || return 0
  log "applying sysfs tweaks from $d"
  for f in "$d"/*.conf; do
    [ -e "$f" ] || continue
    while IFS= read -r line || [ -n "$line" ]; do
      case "$line" in \#*|'') continue;;
        *=*) k="${line%%=*}"; v="${line#*=}";;
        *) continue;;
      esac
      k="$(printf '%s' "$k" | "$BB" sed -r 's/^[[:space:]]+//; s/[[:space:]]+$//')"
      v="$(printf '%s' "$v" | "$BB" sed -r 's/^[[:space:]]+//; s/[[:space:]]+$//')"
      # Warn if an absolute path is not under /sys (it will be rejected by set_sysfs anyway)
      case "$k" in /sys/*) : ;; /*) log "sysfs: warning: absolute path not under /sys: '$k'";; esac
      [ -n "$k" ] && set_sysfs "$k" "$v" || true
    done <"$f"
  done
}

# --- Apply initramfs sysfs.d early (before any external mounts) ---
apply_sysfs_dir "/etc/sysfs.d"

# Given blkid output on stdin, filter by the given key (BusyBox-safe, concise)
# Usage examples:
#   blkid | filter_hint 'LABEL=HP_TOOLS'
#   blkid | filter_hint 'LABEL="ESP SYSTEM"'
#   blkid | filter_hint 'TYPE~/^(vfat|fat|msdos)$/'
#   blkid | filter_hint '/dev/sda1'
filter_hint() {
  "$BB" awk -v hint="$1" -v FS=':' '
    BEGIN {
      if (hint ~ /^[/]dev[/][^:]+$/)             { mode="dev"; hval=hint }
      else if (match(hint, /^([A-Z_]+)([=~].*)$/, kr)) {
        hkey=kr[1]; raw=kr[2]
        if      (match(raw, /^~[/](.*)[/]$/, r)) { mode="re";  hval=r[1] }
        else if (match(raw, /^~(.*)$/, r))       { mode="re";  hval=r[1] }
        else if (match(raw, /^=["](.*)["]$/, r)) { mode="str"; hval=r[1] }
        else if (match(raw, /^=(.*)$/, r))       { mode="str"; hval=r[1] }
      } else exit 2
    }
    (mode=="dev" && $1==hval) { print }
    (mode!="dev" && match($0, FS)) {
      kvs=substr($0, RSTART+RLENGTH);
      while (match(kvs, /[[:space:]]+([A-Z_]+)="([^"]*)"/, kv)) {
        if (kv[1]==hkey && (
            (mode=="re" && kv[2] ~ hval) || (kv[2]==hval)
        )) { print; next }
        kvs=substr(kvs, RSTART+RLENGTH)
      }
    }'
}

# Resolve a device from a "hint" (LABEL=…, UUID=…, TYPE=…, or /dev/…)
resolve_hint() {
  "$BB" blkid | filter_hint "$1" | "$BB" awk -v FS=':' 'NR==1{print $1}'
}

mount_fat_ro() {  # $1:dev $2:mountpoint
  dev="$1"; mnt="$2"
  "$BB" mount -t vfat -o ro,nodev,nosuid,noexec "$dev" "$mnt" 2>/dev/null \
  || "$BB" mount -t vfat -o ro "$dev" "$mnt" 2>/dev/null || return 1
}

VFAT_PARTS=
filter_vfat() { echo -n "$VFAT_PARTS" | filter_hint "$1" || true; }

# ---------- TOOLS (toolbox partition) ----------
if [ -z "${TOOLS_MOUNT:-} " ]; then
  log "WARN: TOOLS_MOUNT not set; payload will be unavailable"
  unset TINYOS_MANIFEST TINYOS_DIR
elif [ -z "${TINYOS_TOKEN:-}" ]; then
  log "WARN: TINYOS_TOKEN not set; payload will be unavailable"
  unset TINYOS_MANIFEST TINYOS_DIR
else
  log "discovering TOOLS partition"
  export TOOLS_DEV=""
  TOOLS_CAND=
  [ -n "$VFAT_PARTS" ] || VFAT_PARTS="$("$BB" blkid | filter_hint 'TYPE=vfat')"

  # Seed from cmdline hint
  if [ -n "${_CMD_TOOLS_HINT:-}" ]; then
    TOOLS_CAND="${TOOLS_CAND}"$'\n'"$(filter_vfat "$_CMD_TOOLS_HINT")"
  fi

  # Seed from config hint
  if [ -n "${TOOLS_HINT:-}" ]; then
    TOOLS_CAND="${TOOLS_CAND}"$'\n'"$(filter_vfat "$TOOLS_HINT")"
  fi

  # Seed from label TOOLS
  TOOLS_CAND="${TOOLS_CAND}"$'\n'"$(filter_vfat 'LABEL~/TOOLS/')"

  # Finally, all vfat partitions
  TOOLS_CAND="${TOOLS_CAND}"$'\n'"${VFAT_PARTS}"

  # Resolve manifest basename
  MANIFEST_NAME="$(subst_template "$MANIFEST_TEMPLATE" "$TINYOS_TOKEN")"

  # Trial mount candidates
  "$BB" mkdir -p "$TOOLS_MOUNT" || true
  TRIAL_MOUNT="$(
    echo "$TOOLS_CAND" \
    | "$BB" awk -v FS=':' '(NF>1 && !seen[$1]) {seen[$1]=1;print $1}' \
    | while read -r CAND_DEV; do
        mount_fat_ro "$CAND_DEV" "$TOOLS_MOUNT"
        if [ -f "$TOOLS_MOUNT/$TINYOS_REL/$MANIFEST_NAME" ]; then
          # Found in expected location
          FOUND_MANIFEST="$TINYOS_REL/$MANIFEST_NAME"
        else
          # Search candidate partition for manifest
          FOUND_MANIFEST="$(
            ( cd "$TOOLS_MOUNT"
              "$BB" find . -type f -iname "$MANIFEST_NAME" -print
            ) || true \
            | "$BB" awk 'NR==1{print substr($0, 3)}'
          )"
        fi
        if [ -n "$FOUND_MANIFEST" ]; then
          printf "%s\n%s\n" "$CAND_DEV" "$FOUND_MANIFEST"
          break
        else
          "$BB" umount "$TOOLS_MOUNT" || true
        fi
      done
  )"
  if [ -n "$TRIAL_MOUNT" ]; then
    export TOOLS_DEV="$(echo "$TRIAL_MOUNT" | "$BB" sed -ne '1p')"
    export TINYOS_MANIFEST="$(echo "$TRIAL_MOUNT" | "$BB" sed -ne '2p')"
    export TINYOS_REL="$("$BB" dirname "$TINYOS_MANIFEST")"
    export TINYOS_DIR="${TOOLS_MOUNT}/${TINYOS_REL}"
  fi

  # Uniform logging regardless of discovery method
  if [ -n "${TOOLS_DEV:-}" ]; then
    log "TOOLS $TOOLS_DEV mounted on $TOOLS_MOUNT"
  else
    msg "WARN: TOOLS not found; payload will be unavailable"
    unset TINYOS_MANIFEST TINYOS_DIR
  fi
fi

# ---------- ESP (real EFI System Partition) ----------
if [ -z "${ESP_MOUNT:-} " ]; then
  log "WARN: ESP_MOUNT not set; system ESP will be unavailable"
else
  log "discovering ESP partition"
  export ESP_DEV=""
  ESP_CAND=
  [ -n "$VFAT_PARTS" ] || VFAT_PARTS="$("$BB" blkid | filter_hint 'TYPE=vfat')"

  # Seed from cmdline hint
  if [ -n "${_CMD_ESP_HINT:-}" ]; then
    ESP_CAND="${ESP_CAND}"$'\n'"$(filter_vfat "$_CMD_ESP_HINT")"
  fi

  # Seed from config hint
  if [ -n "${ESP_HINT:-}" ]; then
    ESP_CAND="${ESP_CAND}"$'\n'"$(filter_vfat "$ESP_HINT")"
  fi

  # Mark explicitly seeded candidates
  ESP_MARK='---'
  ESP_CAND="$(printf "%s\n%s:%s\n" "$ESP_CAND" "$ESP_MARK" "$ESP_MARK")"

  # Seed from label ESP, EFI, or SYS
  ESP_CAND="${ESP_CAND}"$'\n'"$(filter_vfat 'LABEL~/ESP|EFI|SYS/')"

  # Finally, all vfat partitions
  ESP_CAND="${ESP_CAND}"$'\n'"${VFAT_PARTS}"

  # Trial mount candidates
  "$BB" mkdir -p "$ESP_MOUNT" || true
  TRIAL_MOUNT="$(
    echo "$ESP_CAND" \
    | "$BB" awk -v FS=':' -v sep="$ESP_MARK" '
        $1==sep             { print $1; next }
        (NF>1 && !seen[$1]) { print $1; seen[$1]=1 }
      ' \
    | {
        CAND_BOOST=100
        while read -r CAND_DEV; do
          # Find marker
          if [ "$CAND_DEV" == "$ESP_MARK" ]; then
            CAND_BOOST=$(($CAND_BOOST / 2))
            continue
          fi

          # Skip TOOLS partition
          if [ "$CAND_DEV" == "${TOOLS_DEV:-}" ]; then continue; fi

          mount_fat_ro "$CAND_DEV" "$ESP_MOUNT"
          if [ -d "$ESP_MOUNT/EFI" ]; then
            # Calculate score for potential candidate (number of
            # directories containing EFI files)
            ESP_SCORE=$(( $CAND_BOOST + 3 * $(
              cd "$ESP_MOUNT"
              { "$BB" find "EFI" -type f -iname '*.efi' -print || true; } \
              | "$BB" awk -v FS='/' '
                  !seen[$2] { seen[$2]=1 }
                  END       { print length(seen) }
                '
            ) ))

            printf '%s:%s\n' "$CAND_DEV" "$ESP_SCORE"
            [[ $CAND_BOOST -eq 0 ]] || CAND_BOOST=$(($CAND_BOOST - 1))
          fi
          "$BB" umount "$ESP_MOUNT" || true
        done
      } \
    | "$BB" awk -v FS=':' '
        BEGIN           { best_dev=""; best_score=-1; }
        $2 > best_score { best_dev=$1; best_score=$2; }
        END             { if (best_score > 0) print best_dev; }
      '
  )"
  if [ -n "$TRIAL_MOUNT" ]; then
    ESP_DEV="$TRIAL_MOUNT"
    mount_fat_ro "$ESP_DEV" "$ESP_MOUNT"
  fi

  # Uniform logging regardless of discovery method
  if [ -n "${ESP_DEV:-}" ]; then
    log "System ESP $ESP_DEV mounted on $ESP_MOUNT"
  else
    msg "WARN: System ESP not found"
  fi
fi

# Brute-force load all initramfs modules (temporary workaround for console)
KVER="$("$BB" uname -r)"
"$BB" find "/lib/modules/$KVER/" -name '*.ko*' -print0 | "$BB" xargs -r0 modprobe || true

# ---------- Bind in external modules/firmware from HP_TOOLS ----------

# Modules: bind only if directory appears to contain supplemental assets, ignore otherwise
MOD_EXT="$TINYOS_DIR/lib/modules/$KVER"
if [ -d "$MOD_EXT" ] && \
   "$BB" find "$MOD_EXT" \
     -type f \( -name '*.ko' -o -name '*.ko.*' -o -name 'modules.dep*' -o -name 'modules.*' \) \
     -print 2>/dev/null | "$BB" head -n1 >/dev/null; then
  log "mounting kernel modules payload"
  "$BB" mkdir -p "/lib/modules/$KVER"
  "$BB" mountpoint -q "/lib/modules/$KVER" || "$BB" mount --bind "$MOD_EXT" "/lib/modules/$KVER" 2>/dev/null || true
fi

# Firmware: bind (and set runtime search path) only if non-empty and no cmdline override
FW_EXT="$TINYOS_DIR/lib/firmware"
if [ -d "$FW_EXT" ] && \
   "$BB" find "$FW_EXT" -type f -print 2>/dev/null | "$BB" head -n1 >/dev/null; then
  if ! printf '%s' "$CMDLINE" | "$BB" tr ' ' '\n' | "$BB" grep -q '^firmware_class.path='; then
    log "mounting kernel firmware payload"
    "$BB" mkdir -p /lib/firmware
    "$BB" mountpoint -q /lib/firmware || "$BB" mount --bind "$FW_EXT" /lib/firmware 2>/dev/null || true
    set_sysfs "/sys/module/firmware_class/parameters/path" "/lib/firmware" || true
  else
   msg "not mounting kernel firmware payload, search path overridden by kernel cmdline"
  fi
fi

# Apply HP_TOOLS sysfs.d after it’s available
apply_sysfs_dir "$TINYOS_DIR/sysfs.d"

# Optional niceties (ignore failures)
"$BB" modprobe hp_wmi     2>/dev/null || true
"$BB" modprobe lis3lv02d  2>/dev/null || true
"$BB" modprobe rfkill     2>/dev/null || true

msg 'Dropping to shell (type "exit" to resume boot)'
"$BB" setsid "$BB" cttyhack "$BB" sh

msg 'Handing off to BusyBox init (PID stays 1)'
link_bb /sbin/init
exec /sbin/init
panic "/sbin/init failed; dropping to shell"
